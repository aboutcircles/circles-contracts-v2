// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity >=0.8.24;

import {Test} from "forge-std/Test.sol";
import {StdCheats} from "forge-std/StdCheats.sol";
import "forge-std/console.sol";
import "../../src/hub/TypeDefinitions.sol";
import "../../src/operators/SignedPathOperator.sol";
import "../hub/MockDeployment.sol";
import "../setup/TimeCirclesSetup.sol";
import "../setup/HumanRegistration.sol";
import "./TrustGraph.sol";

contract SignedPathOperatorTest is Test, TimeCirclesSetup, HumanRegistration, TrustGraph {
    // Constants

    uint96 expiry = type(uint96).max;

    // State variables

    SignedPathOperator public operator;
    MockHub public hub;
    MockDeployment public deployment;

    // Constructor

    constructor() HumanRegistration(20) {}

    // Setup

    function setUp() public {
        // set time to 10 december 2021
        startTime();

        // deploy all contracts and the signed path operator
        deployment = new MockDeployment(INFLATION_DAY_ZERO, 365 days);
        hub = deployment.hub();
        operator = new SignedPathOperator(IHubV2(address(hub)));

        // register 20 humans
        for (uint256 i = 0; i < N; i++) {
            vm.prank(addresses[i]);
            hub.registerHumanUnrestricted();
            assertEq(deployment.hub().isTrusted(addresses[i], addresses[i]), true);
        }
        // skip time to claim Circles
        skipTime(14 days + 1 minutes);
        for (uint256 i = 0; i < N; i++) {
            vm.prank(addresses[i]);
            hub.personalMintWithoutV1Check();
        }

        // diagram of the trust graph (all doubly connected)

        // 1---2---3       8---9
        // | \ | / |       | / |
        // 12  4---5---7---6---10
        // | / |   |       | \ |
        // 11--13  14      15--16
        // |       |       |   |
        // 20------17------18--19
        _setTrustGraph();
    }

    // Tests

    function testSingleSignedPath() public {
        // Alice is node 11; Bob is node 14
        address alice = addresses[11];

        // only Alice authorizes the operator to execute a signed path on her behalf.
        vm.prank(alice);
        hub.setApprovalForAll(address(operator), true);

        (
            address[] memory flowVertices,
            TypeDefinitions.FlowEdge[] memory flowEdges,
            TypeDefinitions.Stream[] memory streams,
            bytes memory packedCoordinates
        ) = _setupExplicitFlowMatrix01();

        vm.prank(alice);
        operator.operateSignedFlowMatrix(flowVertices, flowEdges, streams, packedCoordinates, lookupMap[11]);
    }

    // Internal functions

    function _setupExplicitFlowMatrix01()
        internal
        view
        returns (address[] memory, TypeDefinitions.FlowEdge[] memory, TypeDefinitions.Stream[] memory, bytes memory)
    {
        uint256 M = 7;

        // make it max width even if we dont touch all nodes
        address[] memory flowVertices = new address[](N);
        // allocate memory for some flow edges already
        TypeDefinitions.FlowEdge[] memory flowEdges = new TypeDefinitions.FlowEdge[](M);

        uint16[] memory coordinates = new uint16[](M * 3);

        // the flow vertices need to be sorted
        for (uint256 i = 0; i < N; i++) {
            flowVertices[i] = sortedAddresses[i];
        }

        // todo: figure out how to effectively define advanced flow matrices programatically;

        uint256 index = 0;

        uint256 j = P1.length - 1;
        // Alice -> Bob along P1
        for (uint256 i = 0; i < j; i++) {
            flowEdges[i] = TypeDefinitions.FlowEdge(uint16(i), uint240(40 * CRC));
            flowEdges[i].streamSinkId = uint16(0);
            coordinates[index++] = lookupMap[P1[i]]; // CRC
            coordinates[index++] = lookupMap[P1[i]]; // source
            coordinates[index++] = lookupMap[P1[i + 1]]; // receiver
        }

        // Alice -> Bob along P2; continue counting with index
        for (uint256 i = j; i < j + P2.length - 1; i++) {
            flowEdges[i] = TypeDefinitions.FlowEdge(uint16(i), uint240(60 * CRC));
            flowEdges[i].streamSinkId = uint16(0);
            coordinates[index++] = lookupMap[P2[i]]; // CRC
            coordinates[index++] = lookupMap[P2[i]]; // source
            coordinates[index++] = lookupMap[P2[i + 1]]; // receiver
        }
        // set the terminal edges to Bob to refer to the first stream (indexed at 1)
        flowEdges[j - 1].streamSinkId = uint16(1);
        flowEdges[j + P2.length - 2].streamSinkId = uint16(1);

        // pack the coordinates
        bytes memory packedCoordinates = packCoordinates(coordinates);

        TypeDefinitions.Stream[] memory streams = new TypeDefinitions.Stream[](1);
        streams[0].sourceCoordinate = lookupMap[11];
        streams[0].flowEdgeIds = new uint16[](2);
        streams[0].flowEdgeIds[0] = uint16(j - 1);
        streams[0].flowEdgeIds[1] = uint16(j + P2.length - 2);
        streams[0].data = new bytes(0);

        return (flowVertices, flowEdges, streams, packedCoordinates);
    }

    function _setTrustGraph() internal {
        _linearlyDoubleConnect20(L1);
        _linearlyDoubleConnect7(L2);
        _fullyConnect3(F1);
        _fullyConnect3(F2);
        _fullyConnect3(F3);
        _fullyConnect3(F4);
        _fullyConnect3(F5);
    }

    function _fullyConnect3(uint256[3] memory _list) internal {
        for (uint256 i = 0; i < _list.length; i++) {
            for (uint256 j = 0; j < _list.length; j++) {
                if (i != j) {
                    vm.prank(addresses[_list[i]]);
                    hub.trust(addresses[_list[j]], expiry);
                }
            }
        }
    }

    function _linearlySingleConnect(uint256[] memory _list) internal {
        for (uint256 i = 0; i < _list.length - 1; i++) {
            vm.prank(addresses[_list[i]]);
            hub.trust(addresses[_list[i + 1]], expiry);
        }
    }

    function _linearlyDoubleConnect20(uint256[20] memory _list) internal {
        for (uint256 i = 0; i < _list.length - 1; i++) {
            vm.prank(addresses[_list[i]]);
            hub.trust(addresses[_list[i + 1]], expiry);
            vm.prank(addresses[_list[i + 1]]);
            hub.trust(addresses[_list[i]], expiry);
        }
    }

    function _linearlyDoubleConnect7(uint256[7] memory _list) internal {
        for (uint256 i = 0; i < _list.length - 1; i++) {
            vm.prank(addresses[_list[i]]);
            hub.trust(addresses[_list[i + 1]], expiry);
            vm.prank(addresses[_list[i + 1]]);
            hub.trust(addresses[_list[i]], expiry);
        }
    }

    // duplicated from test/hub/PathTransferHub.t.sol
    /**
     * @dev Packs an array of uint16 coordinates into bytes.
     * Each coordinate is represented as 16 bits (2 bytes).
     * @param _coordinates The array of uint16 coordinates.
     * @return packedData_ The packed coordinates as bytes.
     */
    function packCoordinates(uint16[] memory _coordinates) private pure returns (bytes memory packedData_) {
        packedData_ = new bytes(_coordinates.length * 2);

        for (uint256 i = 0; i < _coordinates.length; i++) {
            packedData_[2 * i] = bytes1(uint8(_coordinates[i] >> 8)); // High byte
            packedData_[2 * i + 1] = bytes1(uint8(_coordinates[i] & 0xFF)); // Low byte
        }
    }
}
